import asyncio
import logging
import re
import time
from datetime import datetime, timedelta
import pytz

from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

from apps.bot.keyboards.base_menu_keyboards import del_msg_kb, cancel_msg_kb
from apps.bot.keyboards.parsing_sale_keyboards import (change_pars_county_sale_kb,
                                                       parsing_sale_settings_kb)
from apps.bot.service.generate_text_settings import generate_text_pars_sale_settings
from config import regions, regions_name, regions_id
from config_bot import repo_manager
from apps.parser.entities.parser_entity import ParserName

from apps.parser.handlers.parsing_links import open_page_and_scroll
from apps.parser.handlers.parsing_links_for_auto_pars import pars_link_for_auto_pars
from apps.parser.handlers.parsing_price_products import pars_price

router = Router(name="–ü–∞—Ä—Å–∏–Ω–≥ —Ä–∞—Å–ø—Ä–æ–¥–∞–∂–∏")

moscow_tz = pytz.timezone("Europe/Moscow")


class LinksForParsState(StatesGroup):
    new_link = State()
    del_link = State()


@router.callback_query(F.data == "start_parsing_sale")
async def start_parsing_sale_(callback_query: types.CallbackQuery, state: FSMContext) -> None:
    await state.clear()
    await callback_query.message.edit_text(
        "‚úÖ –ü–∞—Ä—Å–µ—Ä –∑–∞–ø—É—â–µ–Ω",
    )

    start_time = time.time()
    sale_links = []
    links = await pars_link_for_auto_pars()
    links.extend(await repo_manager.link_yourself_repo.get_all_links_yourself())
    if len(links) > 0:
        text_response = f"‚õìÔ∏è‚Äçüí• –ù–∞–π–¥–µ–Ω–æ —Ä–∞—Å–ø—Ä–æ–¥–∞–∂: {len(links)} ‚úÖ\n" + "\n".join(links)
        await callback_query.bot.send_message(chat_id=callback_query.from_user.id,
                                              text=text_response)

        all_links_products = await open_page_and_scroll(links)
        sale_links += all_links_products
        country = await repo_manager.country_repo.get_all_county_pars_sale()
        await callback_query.bot.send_message(chat_id=callback_query.from_user.id,
                                              text=f'‚õìÔ∏è‚Äçüí• –ù–∞–π–¥–µ–Ω–æ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∏–≥—Ä—ã: {len(sale_links)} ‚úÖ')
        regions_to_parse = [region for region in regions if country.get(region)]

        # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á
        tasks = [
            pars_price(sale_links, country=regions_id.get(region))
            for region in regions_to_parse
        ]

        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        results = await asyncio.gather(*tasks)

        for (region, (old_links, new_links, exception)) in zip(regions_to_parse, results):
            if not country.get(region):
                continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–µ–≥–∏–æ–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –Ω—É–∂–Ω–æ –ø–∞—Ä—Å–∏—Ç—å

            exception_text = "\n".join(exception)
            logging.error(exception_text)

            await callback_query.bot.send_message(
                chat_id=callback_query.from_user.id,
                text=(
                    f'{regions_name.get(region)} —Å–æ–±—Ä–∞–Ω–æ {len(old_links)} —Ü–µ–Ω ‚úÖ\n'
                    f'üéÆ –ù–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤: {len(new_links)}\n'
                    f'‚ö†Ô∏è –û—à–∏–±–æ–∫: {len(exception)}\n'
                )
            )

        elapsed_time = int(time.time() - start_time)
        await callback_query.bot.send_message(chat_id=callback_query.from_user.id,
                                              text=f'–†–∞–±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ\n'
                                                   f'üìÖ –î–∞—Ç–∞: {datetime.now(moscow_tz).strftime("%d-%m-%Y")}\n'
                                                   f'‚åõÔ∏è –í—Ä–µ–º—è: {datetime.now(moscow_tz).strftime("%H:%M")}\n'
                                                   f'‚è∞ –í—Ä–µ–º—è –ø–∞—Ä—Å–∏–Ω–≥–∞: {str(timedelta(seconds=elapsed_time))[:-3]} –ß–ß:–ú–ú')

        # –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—Å–µ —Ç–æ–≤–∞—Ä—ã –æ–±–Ω—É–ª–∏—Ç—å –ø–æ sale_product
        await repo_manager.product_repo.set_sale_status_false_all_products()
        # –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—Å–µ –∞–π–¥–∏—à–Ω–∏–∫–∏ –æ–±–µ—Ä–Ω—É—Ç—å –≤ —Ä–∞—Å–ø—Ä–æ–¥–∞–∂—É!
        product_ids = [link.split('/')[-2] for link in sale_links]
        await repo_manager.product_repo.set_sale_status_true_for_products(product_ids=product_ids)

    else:
        await callback_query.bot.send_message(chat_id=callback_query.from_user.id,
                                              text='–ë—ã–ª–æ –Ω–∞–π–¥–µ–Ω–æ —Ä–æ–≤–Ω–æ 0 —Å—Å—ã–ª–æ–∫ —Å —Ä–∞—Å–ø—Ä–æ–¥–∞–∂–µ–π :(')

    date = datetime.now(moscow_tz).strftime("%d-%m-%Y")
    await repo_manager.parser_schedule_repo.update_last_run(parser_name=ParserName.SALE, date=date)


@router.callback_query(F.data == "change_pars_regions")
async def change_pars_regions(callback_query: types.CallbackQuery, state: FSMContext) -> None:
    await state.clear()

    country = await repo_manager.country_repo.get_all_county_pars_sale()

    keyboard = change_pars_county_sale_kb(country=country, regions_name=regions_name, regions=regions)
    await callback_query.message.edit_text("–†–µ–≥–∏–æ–Ω—ã –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–µ–Ω:", reply_markup=keyboard)


@router.callback_query(F.data.startswith("change_pars_country:"))
async def toggle_region_status(callback: types.CallbackQuery, state: FSMContext) -> None:
    region = callback.data.split(":")[1]

    country = await repo_manager.country_repo.get_all_county_pars_sale()

    # –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ç—É—Å —Ä–µ–≥–∏–æ–Ω–∞
    new_status = not country.get(region, 0)
    await repo_manager.country_repo.update_region_pars(region, new_status)
    country = await repo_manager.country_repo.get_all_county_pars_sale()

    keyboard = change_pars_county_sale_kb(country=country, regions_name=regions_name, regions=regions)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω—ã:", reply_markup=keyboard)


@router.callback_query(F.data == "settings_pars_sale")
async def settings_pars_sale(callback: types.CallbackQuery, state: FSMContext) -> None:
    text = await generate_text_pars_sale_settings()
    await callback.message.edit_text(text=text,
                             reply_markup=parsing_sale_settings_kb(msg_id=callback.message.message_id),
                             disable_web_page_preview=True,
                             )


@router.callback_query(F.data.startswith("add_link_for_pars"))
async def add_link_for_pars(callback: types.CallbackQuery, state: FSMContext) -> None:
    msg_id = callback.data.split(":")[1]
    await callback.answer()
    call_del = await callback.message.answer(
        text='–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É —Å —Ä–∞—Å–ø—Ä–æ–¥–∞–∂–∞–º–∏!',
        reply_markup=cancel_msg_kb())
    await state.update_data(call_del=call_del, msg_id=msg_id)
    await state.set_state(LinksForParsState.new_link)


@router.message(LinksForParsState.new_link)
async def add_link_for_pars_(message: types.Message, state: FSMContext) -> None:
    data = await state.get_data()
    call_del = data.get("call_del")
    msg_id = int(data.get("msg_id"))
    link = message.text.strip()

    await message.delete()

    URL_REGEX = re.compile(
        r'^(https?://)?(www\.)?([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}(/[\w\-._~:/?#[\]@!$&\'()*+,;=]*)?$'
    )
    all_links = await repo_manager.link_yourself_repo.get_all_links_yourself()

    if URL_REGEX.match(link):
        if link in all_links:
            msg_del = await message.answer("‚ùå –î–∞–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ —É–∂–µ –µ—Å—Ç—å!")
            await asyncio.sleep(2)
            await msg_del.delete()
        else:
            await call_del.edit_text(text=f"‚úÖ –°—Å—ã–ª–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞:\n{link}",
                                     reply_markup=del_msg_kb())
            await repo_manager.link_yourself_repo.create_new_link_yourself(url=link)
            text = await generate_text_pars_sale_settings()
            await message.bot.edit_message_text(
                chat_id=message.from_user.id,
                message_id=msg_id,
                text=text,
                reply_markup=parsing_sale_settings_kb(msg_id=msg_id),
                disable_web_page_preview=True,

            )
            await state.clear()
    else:
        msg_del = await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É.")
        await asyncio.sleep(2)
        await msg_del.delete()


@router.callback_query(F.data.startswith("del_link_for_pars"))
async def del_link_for_pars(callback: types.CallbackQuery, state: FSMContext) -> None:
    msg_id = callback.data.split(":")[1]
    await callback.answer()
    call_del = await callback.message.answer(
        text='–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è!',
        reply_markup=cancel_msg_kb())
    await state.update_data(call_del=call_del, msg_id=msg_id)
    await state.set_state(LinksForParsState.del_link)


@router.message(LinksForParsState.del_link)
async def del_link_for_pars_(message: types.Message, state: FSMContext) -> None:
    data = await state.get_data()
    call_del = data.get("call_del")
    msg_id = int(data.get("msg_id"))
    link = message.text.strip()
    await message.delete()
    all_links = await repo_manager.link_yourself_repo.get_all_links_yourself()
    if link in all_links:
        await call_del.edit_text(text=f"‚úÖ –°—Å—ã–ª–∫–∞ —É–¥–∞–ª–µ–Ω–∞:\n{link}",
                                 reply_markup=del_msg_kb())
        await repo_manager.link_yourself_repo.delete_link_yourself(url=link)
        text = await generate_text_pars_sale_settings()
        await message.bot.edit_message_text(
            chat_id=message.from_user.id,
            message_id=msg_id,
            text=text,
            reply_markup=parsing_sale_settings_kb(msg_id=msg_id),
            disable_web_page_preview=True,
        )
        await state.clear()
    else:
        msg_del = await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É.")
        await asyncio.sleep(2)
        await msg_del.delete()